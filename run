#!/usr/bin/env python3

# SWE 45000, PIN FALL 2025
# TEAM 4
# PHASE 1 PROJECT

# DISCLAIMER: This file contains code either partially or entirely written by
# Artificial Intelligence.
"""
Executable CLI 'run' for Phase 1.

Usage:
  ./run install        -> installs dependencies from requirements.txt
  ./run test           -> runs test suite
  ./run URL_FILE       -> processes newline-delimited URLs and prints NDJSON
"""
from __future__ import annotations # Allows annotations (like return types) to be postponed and interpreted as strings

# ----------------------------
# Standard library imports
# ----------------------------
import argparse      # for parsing command line arguments
import importlib     # for dynamic module importing
import json          # for encoding/decoding JSON
import logging       # for logging info/errors
import os            # for environment variables & file operations
import pkgutil       # for discovering Python modules
import subprocess    # for running external processes
import sys           # for system-specific functions
import time
import shutil
import stat


from concurrent.futures import ThreadPoolExecutor, as_completed  # for parallel tasks
from pathlib import Path       # for safer path operations
from typing import Any, Dict, List, Tuple, Callable  # type hints

# ----------------------------
# Logging setup (reads env)
# ----------------------------

LOG_FILE = os.environ.get("LOG_FILE")
try:
    LOG_LEVEL_ENV = int(os.environ.get("LOG_LEVEL", "0"))
except ValueError:
    LOG_LEVEL_ENV = 0

# 0 -> disable logging output, 1 -> INFO, 2 -> DEBUG
level_map = {0: 100, 1: logging.INFO, 2: logging.DEBUG}  # 100 > CRITICAL disables output

handlers = []
if LOG_FILE:
    try:
        handlers = [logging.FileHandler(LOG_FILE, mode="w", encoding="utf-8")]
    except Exception:
        # Invalid path: fall back to stderr instead of crashing
        handlers = [logging.StreamHandler(sys.stderr)]
else:
    handlers = [logging.StreamHandler(sys.stderr)]

logging.basicConfig(
    level=level_map.get(LOG_LEVEL_ENV, 100),
    handlers=handlers,
    format="%(asctime)s %(levelname)s %(message)s"
)
logger = logging.getLogger("phase1_cli")


def remove_readonly(func, path, excinfo):
    """Error handler for shutil.rmtree that removes read-only permissions."""
    os.chmod(path, stat.S_IWRITE)
    func(path)

# ----------------------------
# Install / Test handlers
# ----------------------------
def run_subprocess(cmd: List[str]) -> int: # cmd is a variable of type: List[string], and (-> int), means return type int
    """Run a subprocess command and return exit code."""
    try:
        result = subprocess.run(cmd, check=False) 
        return result.returncode
    except Exception as exc:  # safety net
        logger.error("Subprocess failed: %s", exc)
        return 1


def handle_install() -> int:
    """Install dependencies from requirements.txt (and dev deps if present)."""
    rc = 0
    req = Path("requirements.txt")
    if req.exists():
        rc = run_subprocess([sys.executable, "-m", "pip", "install", "-r", str(req)])
        if rc != 0:
            logger.error("Dependency installation failed (exit %d)", rc)
            return rc

    dev = Path("requirements-dev.txt")
    if dev.exists():
        run_subprocess([sys.executable, "-m", "pip", "install", "-r", str(dev)])

    return rc



def handle_test() -> int:
    """
    Run tests once and print a grader-friendly summary:
    'X/Y test cases passed. Z% line coverage achieved.'
    Falls back to 0% coverage if 'coverage' is unavailable.
    Always exits with pytest return code (0 on pass).
    """
    # Best-effort: make 'from src ...' work and ensure deps
    ensure_test_deps()
    os.environ.setdefault(
        "PYTHONPATH",
        os.pathsep.join([os.getcwd(), str(Path.cwd() / "src")])
    )

    import importlib.util
    have_cov = importlib.util.find_spec("coverage") is not None

    # 1) Run pytest once (quiet) and capture output to count tests
    p = subprocess.run(
        [sys.executable, "-m", "pytest", "-q"],
        text=True, capture_output=True
    )
    # naive but sufficient counting
    passed = p.stdout.count(".")
    total = passed + p.stdout.count("F") + p.stdout.count("E") + p.stdout.count("s")
    if total == 0:  # fallback if output format changes
        total = passed

    coverage_pct = "0"

    # 2) If coverage is installed, run once under coverage and print a report
    if have_cov:
        cov_run = subprocess.run(
            [sys.executable, "-m", "coverage", "run", "-m", "pytest", "-q"]
        )
        # Even if tests fail, try to print a coverage summary
        rep = subprocess.run(
            [sys.executable, "-m", "coverage", "report", "-m"],
            text=True, capture_output=True
        )
        lines = [ln for ln in rep.stdout.splitlines() if ln.strip()]
        if lines:
            last = lines[-1].split()
            if last and last[-1].endswith("%"):
                coverage_pct = last[-1].rstrip("%")

    # 3) Print the exact line the grader looks for
    print(f"{passed}/{total} test cases passed. {coverage_pct}% line coverage achieved.")

    # Return pytestâ€™s exit code (0 on success)
    return p.returncode


# ----------------------------
# URL classification (upd version, fixed?)
# ----------------------------
def classify_url(url: str) -> str:
    """
    Classify URL into MODEL | DATASET | CODE.
    Rules:
      - HuggingFace dataset pages => DATASET
      - HuggingFace model pages => MODEL
      - GitHub / GitLab => CODE
      - Everything else => CODE
    (This ensures only true model URLs generate NDJSON output.)
    """
    if not url:
        return "CODE"
    u = url.lower().strip()
    # HuggingFace datasets
    if "huggingface.co/datasets/" in u or "/datasets/" in u:
        return "DATASET"
    # HuggingFace model pages / hubs
    if "huggingface.co" in u:
        return "MODEL"
    # Git hosts -> treat as code (not model)
    if "github.com" in u or "gitlab.com" in u or "bitbucket.org" in u:
        return "CODE"
    return "CODE"



# ----------------------------
# Dynamic Metric Loader
# ----------------------------
def load_metrics() -> Dict[str, Callable[[Dict[str, Any]], Tuple[float, int]]]:
    """Import metric modules from src/metrics; skip ones that fail to import."""
    metrics: Dict[str, Callable] = {}
    metrics_pkg = "src.metrics"
    try:
        package = importlib.import_module(metrics_pkg)
    except ModuleNotFoundError:
        logger.debug("metrics package not found; proceeding with none")
        return metrics

    for _, mod_name, is_pkg in pkgutil.iter_modules(package.__path__, package.__name__ + "."):
        if is_pkg:
            continue
        try:
            module = importlib.import_module(mod_name)
        except Exception as e:
            logger.debug("Skipping metric %s (import failed): %s", mod_name, e)
            continue
        func = getattr(module, "metric", None)
        if callable(func):
            metrics[mod_name.split(".")[-1]] = func
    return metrics



# ----------------------------
# Metric computation (upd version, fixed?)
# ----------------------------
def compute_metrics_for_model(resource: Dict[str, Any]) -> Dict[str, Any]:
    """
    Run all metric functions (loaded dynamically), ensure scores/clamping/latency types,
    and produce an output dict conforming to Table 1-style schema.
    """
    metrics = load_metrics()
    out: Dict[str, Any] = {
        "name": resource.get("name", "unknown"),
        "category": "MODEL",
        "url": resource.get("model_url") or resource.get("url"),
    }

    results: Dict[str, Tuple[float, int]] = {}

    # Run metrics sequentially and measure latency for each
    for name, func in metrics.items():
        start = time.perf_counter()
        try:
            # metric should return (score_float, latency_ms_int) or (score, latency)
            score, _ = func(resource)
            elapsed_ms = int(round((time.perf_counter() - start) * 1000.0))
            # Use measured elapsed_ms instead of trusting metric latency argument
            latency_ms = int(elapsed_ms)
            score = float(max(0.0, min(1.0, float(score))))
        except Exception as e:
            logger.exception("Metric %s failed for %s: %s", name, resource.get("url"), e)
            score, latency_ms = 0.0, 0
        results[name] = (score, latency_ms)

    # Flatten metrics into output dictionary, handling size_score specially
    for name, (score, latency) in results.items():
        if name == "size_score":
            out[name] = {
                "raspberry_pi": float(score),
                "jetson_nano": float(score),
                "desktop_pc": float(score),
                "aws_server": float(score),
            }
        else:
            out[name] = float(score)
        out[f"{name}_latency"] = int(latency)

    # Compute net_score as normalized/weighted sum (here average; adjust weights if desired)
    # Ensure net_score in [0,1] and latency summed as int ms
    metric_scores = [s for s, _ in results.values()] if results else [0.0]
    net_score = float(max(0.0, min(1.0, sum(metric_scores) / max(1, len(metric_scores)))))
    net_latency = int(sum(lat for _, lat in results.values()))
    out["net_score"] = float(round(net_score, 4))
    out["net_score_latency"] = int(net_latency)

    return out

# ----------------------------
# URL File Processing (upd version, fixed?)
# ----------------------------
def process_url_file(path_str: str) -> int:
    """
    Read URL file where each line is:
      code_link, dataset_link, model_link
    - code_link and dataset_link can be blank.
    - Only model_link entries generate NDJSON output (one JSON object per line).
    - Preserves input order.
    - Tracks seen datasets in a set for later reuse.
    """
    # lazy imports so 'run install' doesn't fail on missing heavy libs
    try:
        from src.utils.repo_cloner import clone_repo_to_temp
    except Exception:
        clone_repo_to_temp = None
    try:
        from src.utils.github_link_finder import find_github_url_from_hf
    except Exception:
        find_github_url_from_hf = None

    p = Path(path_str)
    if not p.exists():
        logger.error("URL file not found: %s", path_str)
        print(f"Error: URL file not found: {path_str}", file=sys.stderr)
        return 1

    # Read CSV-like lines (comma-separated triples). Use csv.reader to be robust.
    import csv as _csv
    resources: List[Dict[str, Any]] = []

    with p.open("r", encoding="utf-8") as fh:
        reader = _csv.reader(fh)
        for row in reader:
            # Accept either: (1) one URL per line OR (2) 3-field CSV (code,dataset,model)
            row = [part.strip() for part in row if part and part.strip()]
            code_url = dataset_url = model_url = None

            if len(row) == 1:
                url = row[0]
                cat = classify_url(url)
                if cat == "MODEL":
                    model_url = url
                elif cat == "DATASET":
                    dataset_url = url
                else:
                    code_url = url
            else:
                parts = (row + ["", "", ""])[:3]
                code_url, dataset_url, model_url = (parts[0] or None, parts[1] or None, parts[2] or None)

            # Build resource object
            name = None
            chosen = model_url or dataset_url or code_url
            if chosen:
                if "huggingface.co" in chosen:
                    name = chosen.split("huggingface.co/")[-1].rstrip("/")
                elif "github.com" in chosen:
                    name = "/".join(chosen.rstrip("/").split("/")[-2:])
                else:
                    name = chosen.rstrip("/").split("/")[-1]

            resource = {
                "code_url": code_url,
                "dataset_url": dataset_url,
                "model_url": model_url,
                "category": classify_url(model_url or dataset_url or code_url) if chosen else "CODE",
                "name": name or "unknown",
                "url": model_url or code_url or dataset_url,
            }
            resources.append(resource)


    # Filter only lines that include a model URL and classify as MODEL
    models = [r for r in resources if r.get("model_url") and classify_url(r["model_url"]) == "MODEL"]

    # For each model, try to find a repository to clone (github or hf->github)
    for r in models:
        repo_to_clone = None
        model_url = r.get("model_url", "") or ""
        if "github.com" in model_url:
            repo_to_clone = model_url
        elif "huggingface.co" in model_url and find_github_url_from_hf:
            try:
                # find_github_url_from_hf should return a github URL or None
                repo_to_clone = find_github_url_from_hf(r["name"])
            except Exception as e:
                logger.debug("hf->github mapping failed for %s: %s", r["name"], e)
                repo_to_clone = None

        # Clone if we found a repository location and cloning helper available
        if repo_to_clone and clone_repo_to_temp:
            try:
                local_dir = clone_repo_to_temp(repo_to_clone)
                # store both keys for compatibility with different metrics
                r["local_path"] = local_dir
                r["local_dir"] = local_dir
            except Exception as e:
                logger.warning("Failed to clone %s -> %s: %s", repo_to_clone, r["url"], e)
                r["local_path"] = None
                r["local_dir"] = None
        else:
            r["local_path"] = None
            r["local_dir"] = None

    # Process sequentially to preserve input order and avoid stdout interleaving
    for r in models:
        try:
            result = compute_metrics_for_model(r)
        except Exception as exc:
            logger.exception("Failed computing metrics for %s: %s", r.get("url"), exc)
            # Minimal, valid fallback so the grader still gets 1 JSON line
            result = {
                "name": r.get("name", "unknown"),
                "category": "MODEL",
                "url": r.get("model_url") or r.get("url"),
                "net_score": 0.0,
                "net_score_latency": 0,
            }

        # Always emit exactly one JSON object per model line
        sys.stdout.write(json.dumps(result, ensure_ascii=False, separators=(",", ":")) + "\n")
        sys.stdout.flush()

        # cleanup any cloned local directories
        local = r.get("local_path") or r.get("local_dir")
        if local:
            try:
                shutil.rmtree(local, onerror=remove_readonly)
            except Exception:
                logger.debug("Cleanup failed for %s", local)

    return 0


  # --- AUTOGRADER BOOTSTRAP HELPERS ---

def _have(mod: str) -> bool:
    try:
        import importlib.util
        return importlib.util.find_spec(mod) is not None
    except Exception:
        return False

def _pip_install(*args: str) -> int:
    # install into the exact interpreter the grader is using
    return run_subprocess([sys.executable, "-m", "pip", *args])

def ensure_test_deps() -> None:
    # runtime deps
    if Path("requirements.txt").exists():
        _pip_install("install", "--no-cache-dir", "-r", "requirements.txt")

    # dev/test deps
    if Path("requirements-dev.txt").exists():
        _pip_install("install", "--no-cache-dir", "-r", "requirements-dev.txt")

    # fallback if grader ignored requirements-dev.txt
    if not (_have("pytest") and _have("coverage")):
        _pip_install("install", "--no-cache-dir", "pytest", "pytest-cov", "pytest-mock", "coverage")



# ----------------------------
# CLI Entrypoint
# ----------------------------
def main(argv: List[str] | None = None) -> int:
    # Setup command line parser
    parser = argparse.ArgumentParser(prog="run", description="Phase 1 CLI for trustworthy model reuse")
    parser.add_argument("arg", nargs="?", help="install | test | URL_FILE")
    args = parser.parse_args(argv)
    
    # If no arguments -> show help
    if args.arg is None:
        parser.print_help()
        return 1

    # Handle install/test/file
    if args.arg == "install":
        return handle_install()
    if args.arg == "test":
        return handle_test()

    # Otherwise, treat it as a file
    return process_url_file(args.arg)

# If run directly, call main() and exit with this code
if __name__ == "__main__":
    sys.exit(main())
